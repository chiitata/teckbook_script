== UI/UXの改善

本書では、アプリケーションのコア機能の実装に焦点を当ててきました。この最終章では、完成したアプリケーションをさらに洗練させ、ユーザーにとってより使いやすいものにするための改善案をいくつか紹介します。

=== ローディングスケルトンの導入

第4章では、データ検索中に「検索中...」というテキストを表示する簡単なローディング処理を実装しました。これをさらに一歩進めて、「ローディングスケルトン」を導入してみましょう。

ローディングスケルトンとは、コンテンツが読み込まれる場所に、そのコンテンツの概形を模したプレースホルダー（灰色のアニメーションなど）を表示する手法です。これにより、ユーザーは「何がどこに表示されるのか」を予測でき、体感的な待ち時間を短縮する効果があります。

#image[loading-skeleton][ローディングスケルトンの例]{
#}

**実装のヒント:**

 * 検索結果の動画カードと同じレイアウトで、中身がグレーアウトされた「スケルトンカード」コンポーネントを作成します。
 * `loading`状態が`true`の間、このスケルトンカードを複数個表示させます。
 * Tailwind CSSの`animate-pulse`クラスを使うと、簡単に脈打つようなアニメーション効果を追加できます。

=== トースト通知によるフィードバック

現在、お気に入り登録・解除や、エラー発生時のフィードバックは、画面の一部にテキストを表示するだけです。これを「トースト通知」に変更することで、ユーザー体験を向上させることができます。

トースト通知とは、画面の隅に短時間表示されてから自動的に消える、小さなメッセージのことです。「お気に入りに追加しました」「エラーが発生しました」といった操作結果を、ユーザーの作業を妨げることなく伝えるのに適しています。

#image[toast-notification][トースト通知の例]{
#}

**実装のヒント:**

 * `react-hot-toast`や`sonner`といった、人気のライブラリを利用するのが簡単でおすすめです。
 * Server Actionの実行後、その結果（成功・失敗）に応じてトースト通知を表示する処理をクライアントサイドで呼び出します。

=== 無限スクロールの実装

現在の動画検索結果は、最大10件しか表示されません。YouTubeのように、ページの下部までスクロールすると次の検索結果が自動的に読み込まれる「無限スクロール」を実装すると、より多くの動画をスムーズに閲覧できるようになります。

**実装のヒント:**

 * YouTube APIの`search.list`メソッドには、次のページの検索結果を取得するための`pageToken`というパラメータがあります。1回目の検索結果のレスポンスに含まれる`nextPageToken`を保存しておき、2回目以降の検索で`pageToken`として渡します。
 * `react-intersection-observer`などのライブラリを使い、検索結果リストの末尾の要素が画面に表示されたことを検知して、次のページを読み込むServer Actionをトリガーします。

=== レスポンシブデザインの改善

本書では、Tailwind CSSの`sm:`や`md:`といったブレークポイントを使って、基本的なレスポンシブ対応を行いました。しかし、スマートフォンの小さな画面では、まだ見づらい部分があるかもしれません。

 * 文字サイズや余白は適切か？
 * ボタンはタップしやすい大きさか？
 * 横長の動画サムネイルが縦に並んで、スペースを使いすぎていないか？

実際にブラウザの開発者ツールでモバイル表示をシミュレートしたり、実機で確認したりしながら、細部を調整していくことが重要です。

これらの改善は、アプリケーションの「機能」を増やすものではありませんが、ユーザーの満足度を大きく左右する重要な要素です。ぜひ、本書で得た知識を元に、あなただけのオリジナルアプリケーションを育てていってください。
== Supabaseの高度な機能

本書ではSupabaseの基本的な機能であるデータベース、認証、RLSを中心に使ってきました。しかし、Supabaseにはアプリケーションをさらに強力にするための高度な機能がまだまだあります。ここではその一部を紹介します。

=== Realtime: リアルタイムなUI更新

Supabaseの「Realtime」機能を使うと、データベースの変更をリアルタイムにクライアントに通知させることができます。これにより、他のユーザーが行った操作を、ページをリロードすることなく即座にUIに反映させるといった、インタラクティブな体験を実現できます。

例えば、「他の誰かがお気に入り登録した動画」をリアルタイムで表示する、といった機能が考えられます。

**実装のヒント:**

 1. Supabaseのダッシュボードで、`favorites`テーブルのRealtimeを有効にします。
 2. クライアントサイドで、`supabase.channel(...).on(...).subscribe()`を使って、`favorites`テーブルへの`INSERT`イベントを購読します。

```javascript
# Realtime機能の実装例
const channel = supabase.channel('favorites-feed')
  .on(
    'postgres_changes',
    { event: 'INSERT', schema: 'public', table: 'favorites' },
    (payload) => {
      console.log('New favorite added!', payload.new)
      # ここでUIを更新する処理（例: トースト通知を表示）
    }
  )
  .subscribe()
```

この機能を使えば、チャットアプリケーションや共同編集ツールなど、より動的なアプリケーションを構築できます。

=== Edge Functions: サーバーサイドロジックの実行

「Edge Functions」は、Denoで書かれたTypeScriptのコードを、サーバーレス環境で実行できる機能です。通常、クライアントから直接実行されたくない、あるいは実行できないような、より複雑なサーバーサイドロジックを実装するのに使います。

例えば、以下のようなケースで役立ちます。

 * **外部APIとの連携**: クライアントに公開したくないAPIキーを使って、外部のサービスと連携する。
 * **複雑なデータ処理**: 複数のテーブルにまたがるような、重いデータベース処理を実行する。
 * **Stripeを使った決済処理**: 決済サービスStripeと連携し、支払い処理を実行する。

Edge Functionsは、世界中のエッジロケーション（ユーザーに近いサーバー）で実行されるため、非常に高速に応答を返すことができます。

=== Storage: ファイルストレージ

本書では扱いませんでしたが、Supabaseには「Storage」という、画像や動画、PDFなどの大容量ファイルを保存するための機能もあります。

例えば、ユーザーがプロフィール画像をアップロードする機能を実装したい場合に、このStorageを利用します。Storageもデータベースと同様に、RLSのような詳細なアクセスポリシーを設定でき、「自分のフォルダにしかアップロードできない」「他人のファイルは閲覧はできるが削除はできない」といった制御が可能です。

=== さらなる学習のために

ここで紹介した機能はほんの一部です。Supabaseの公式ドキュメントは非常に充実しており、各機能の詳細な使い方やチュートリアルが豊富に用意されています。

 * [Supabase Documentation](https://supabase.com/docs)

本書で基本をマスターしたあなたなら、ドキュメントを読み解きながら、これらの高度な機能を自分のアプリケーションに組み込んでいくことができるはずです。ぜひ挑戦してみてください。
== Next.jsの最適化

Next.jsはデフォルトでも高いパフォーマンスを発揮しますが、その真価は豊富な最適化機能にあります。ここでは、アプリケーションのパフォーマンスをさらに向上させるためのいくつかの重要なトピックを紹介します。

=== 画像の最適化 (`next/image`)

Webサイトの表示速度に大きな影響を与える要素の一つが画像です。Next.jsには、画像を自動的に最適化してくれる`<Image>`コンポーネント（`next/image`）が組み込まれています。

現在、検索結果のサムネイル表示には通常の`<img>`タグを使用していますが、これを`<Image>`コンポーネントに置き換えることで、以下のようなメリットが得られます。

 * **自動的なフォーマット変換**: ブラウザが対応していれば、JPEGやPNGといった従来のフォーマットより軽量なWebPやAVIF形式で画像を配信します。
 * **リサイズの最適化**: デバイスの画面サイズに応じた、適切なサイズの画像を自動的に生成・配信します。これにより、不必要に大きな画像をダウンロードさせることを防ぎます。
 * **遅延読み込み（Lazy Loading）**: 画面に表示されていない画像（スクロールしないと見えない場所にある画像）の読み込みを、画面内に入るまで遅延させます。初期表示の高速化に大きく貢献します。

```tsx
# <Image>コンポーネントの使用例
import Image from 'next/image'

# ...

<Image
  src={fav.thumbnail_url} // 外部URLの場合、設定が必要
  alt={fav.video_title}
  width={320} // 表示する幅
  height={180} // 表示する高さ
  className="w-full rounded-md mb-2"
/>
```

NOTE: 外部ドメインの画像（今回のようにYouTubeのサムネイルなど）を`<Image>`コンポーネントで利用するには、`next.config.js`ファイルにドメインを登録する必要があります。

=== キャッシュ戦略

Next.jsのApp Routerは、非常に強力なキャッシュ機構を備えています。Server Componentsが`fetch`を使って取得したデータは、デフォルトで永続的にキャッシュされます。これにより、ビルド時に取得したデータを、リクエストのたびに再取得することなく高速に表示できます。

しかし、今回のように検索機能など、常に最新のデータを表示したい場合もあります。`fetch`のオプションを調整することで、キャッシュの挙動を細かく制御できます。

```javascript
# キャッシュを無効にする例
fetch('https://...', { cache: 'no-store' })

# 一定時間（例: 60秒）だけキャッシュする例 (ISR: Incremental Static Regeneration)
fetch('https://...', { next: { revalidate: 60 } })
```

Supabaseのクライアントライブラリは内部で`fetch`を使用しているため、これらのキャッシュ戦略と組み合わせて利用することも可能です。（詳細は公式ドキュメントを参照してください）

ページの特性（更新頻度など）に応じて適切なキャッシュ戦略を選択することが、パフォーマンスとデータの鮮度を両立させる鍵となります。

=== 動的レンダリングと静的レンダリング

App Routerでは、ページが動的レンダリングされるか、静的レンダリング（SSG: Static Site Generation）されるかが、コードの内容によって自動的に決まります。

 * **静的レンダリング**: ページ内で`cookies()`や`headers()`といった動的な関数や、キャッシュを無効にした`fetch`が使われていない場合、そのページはビルド時に静的なHTMLとして生成されます。CDNから配信できるため、非常に高速です。
 * **動的レンダリング**: 動的な関数が使われている場合、ページはリクエストごとにサーバーでレンダリングされます。

例えば、お気に入り一覧を表示するマイページは、`cookies()`を使ってユーザー認証を行っているため、動的レンダリングされます。一方で、企業の製品紹介ページのような、内容が頻繁に変わらないページは静的レンダリングの恩恵を最大限に受けることができます。

Next.jsのこれらの最適化機能を理解し、使いこなすことで、ユーザー体験を劇的に向上させることができます。ぜひ公式ドキュメントを片手に、さらなるパフォーマンスの追求に挑戦してみてください。
