== RLS（Row Level Security）の深掘り

これまでの実装で、`profiles`テーブルと`favorites`テーブルの作成時に、RLS（Row Level Security）を有効にし、いくつかのポリシーを作成しました。このセクションでは、Supabaseの根幹をなすこの強力な機能について、改めてその重要性と仕組みを詳しく解説します。

=== なぜRLSが必要なのか？

Supabaseでは、クライアントサイド（ブラウザ）から直接データベースのデータを読み書きできます。これは開発を非常に高速化しますが、同時に大きなセキュリティリスクも伴います。

もし、何の制限もなければ、悪意のあるユーザーがブラウザの開発者ツールを使い、他人の`user_id`を指定して、その人のお気に入り情報を盗み見たり、勝手に追加・削除したりできてしまいます。

```javascript
# 悪意のあるコードの例（もしRLSがなければ...）

# 他人のIDを指定して、その人のお気に入りを全て取得
supabase.from('favorites').select('*').eq('user_id', '他人のID')

# 他人のIDを使って、勝手にお気に入りを追加
supabase.from('favorites').insert({ user_id: '他人のID', video_id: '...' })
```

このような不正な操作を防ぐために、RLSが必要不可欠です。

=== RLS: データベースの番人

RLSを有効にすると、テーブルへの全てのアクセス（`SELECT`, `INSERT`, `UPDATE`, `DELETE`）がデフォルトで拒否されます。そして、「ポリシー」で許可された操作しか実行できなくなります。

ポリシーは、「**誰が**」「**どの行に対して**」「**何をしても良いか**」を定義するルールです。PostgreSQLのデータベースレベルで強制されるため、クライアントからのリクエストがどのようなものであっても、このルールを迂回することはできません。

=== ポリシーの再確認

`favorites`テーブルに設定したポリシーをもう一度見てみましょう。

```sql
-- 自分のデータしか読み取れない
create policy "Users can view their own favorites." on public.favorites
  for select using (auth.uid() = user_id);
```

この`SELECT`ポリシーは、以下のように解釈できます。

 * **`for select`**: `SELECT`（読み取り）操作に対するルールです。
 * **`using (auth.uid() = user_id)`**: テーブルの行（レコード）のうち、`user_id`カラムの値が、現在リクエストを行っている認証済みユーザーのID（`auth.uid()`）と等しい行**のみ**を、操作の対象とすることを許可します。

`auth.uid()`は、Supabaseが提供する特殊な関数で、リクエストに付与されたJWT（JSON Web Token）からユーザーIDを安全に抽出して返してくれます。

このポリシーのおかげで、たとえクライアントが `supabase.from('favorites').select('*')` というリクエスト（全てのデータを要求）を送ったとしても、データベースは自動的に `WHERE user_id = 'ログイン中のユーザーID'` という条件を追加して、そのユーザー自身のデータだけを返してくれます。

`INSERT`や`DELETE`のポリシーも同様に、`auth.uid()`を使って操作を自分のデータのみに制限しています。

=== RLSは最後の砦

アプリケーションをセキュアに保つためには、クライアントサイドでのバリデーションや、サーバーサイドでのチェックなど、複数の防御層を設けるのが基本です。しかし、最終的にデータベースへのアクセスを制御するRLSは、最も重要な「最後の砦」と言えます。

Supabaseを使う上で、RLSを正しく理解し、設定することは、安全なアプリケーションを構築するための必須スキルです。

これで第6章は完了です。お気に入り機能の実装を通じて、Supabaseのデータベース操作とセキュリティの基本を学びました。次の章では、開発したアプリケーションを世界に公開する「デプロイ」作業を行います。
